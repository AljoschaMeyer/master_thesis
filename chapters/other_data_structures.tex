% !TEX root = ../main.tex

In this chapter, we sketch some adaptations of the set reconciliation algorithm to related problems. \Cref{general-partitions} considers more general partioning strategies than one-dimensional intervals. \Cref{maps} presents how to reconcile key-value mappings. \Cref{set-mirror} shows an asymmetric variant of the protocol, mirroring the contents of a set or map held at a primary node to a replica node.

\section{Higher-Dimensional Intervals}
\label{general-partitions}

The set reconciliation algorithm recursively partitions the item sets of both nodes by splitting the sets into successive intervals. But for the correctness of the algorithm, the exact mechanism by which partitions are chosen is irrelevant. All that is necessary is that in each communication round, when receiving a mismatching fingerprint for some non-empty $S \subseteq U$, the node chooses a partition $\disjointunion{S_0}{\disjointunion{S_1}{\disjointunion{\ldots}{S_k}}} = S$ of $S$, and then communicates to the other node the choice of the partition and how its items are distributed among the individual sets.

Partitioning into successive intervals over a linearly ordered set has some nice properties: It can be applied to virtually any set since one can always arbitrarily define a linear order. The choice of the partition and the way the items are distributed among the sets can be encoded and transmitted efficiently. And finally, when receiving and arbitrarily chosen partition into successive intervals, a node can always efficiently compute the items it holds within that partition as well as the fingerprint over these items.

As long as nodes always wants to synchronize the whole sets they hold, this is completely sufficient. But more elaborate partitioning strategies can become attractive if nodes might wish to only synchronize certain subsets. The partitioning mechanism effectively dictates which such subsets can be described, taking on the role of a query language. A natural next step is to look for more powerful partitioning mechanisms that still admit efficient fingerprint computation.

We now give one such partitioning scheme by generalizing the one-dimensional intervals of the original presentation of the algorithm to $k$-dimensional intervals. Let $U$ be a finite set of items, and let $\preceq_0, \preceq_1, \ldots, \preceq_{k-1}$ be linear orders over $U$. A \defined{$k$-dimensional interval} is a $k$-tuple $((x_0, y_0), (x_1, y_1), \ldots, (x_{k-1}, y_{k-1}))$ with $x_i \preceq_i y_i$. Given some $S \subseteq U$, the items from $S$ in this interval are all items $v \in S$ such that $x_i \preceq_i v \preceq_i y_i$ for all $0 \leq i < k$. Note that for $k = 1$ this is equivalent to the intervals used in previous chapters. The reconciliation protocol needs to be adapted so that messages include the $k$-dimensional interval boundaries, but otherwise no changes are required.

Fingerprints can be computed efficiently by storing the set as a (balanced) $k$-d tree~\cite{bentley1975multidimensional}. As $k$-d tree are binary trees, the labels from \cref{fingerprints} can be used without any modification. Fingerprint computation still works by traversing the tree, alternating between the dimensions just as in e.g. a $k$-d tree item lookup. For $k = 1$, this is exactly the algorithms of \cref{fingerprints}.

Generalized partitioning schemes, including $k$-dimensional intervals, can not only be applied to the regular set reconciliation protocol, but also to all modifications discussed in the further sections.

\section{Map Reconciliation}
\label{maps}

A key-value mapping, i.e. a partial function $\partialfun{\m}{K}{V}$ with a finite domain from some set of keys $K$ to a set of values $V$, can be reconciled by reconciling the set $\set{(k, v) \mid \text{$k \in \domain(\m)$ and $v = \m(k)$}}$. After this reconciliation, a node may have obtained two pairs $(k, v), (k, v')$ if the two nodes mapped the same key $k$ to distinct values $v, v'$, so the resulting set would not correspond to an updated map. In those cases, both nodes compute the single new image of $k$ as $\f(v, v')$, where $\fun{\f}{V \times V}{V}$ is some function known to all participating nodes.

A particularly interesting case is that where $\f$ can be computed via another interactive protocol. If for example $V$ consists of the fingerprints of finite subsets of some universe $U$, and $\f(v, v')$ is defined to be the fingerprint of the union of the two sets whose fingerprints are $v$ and $v'$, then the two nodes can run a set reconciliation session to efficiently obtain the union. Viewn more abstractly, when reconciling a map, the values can be reconciled via arbitrary nested protocol invocations.

\section{Set and Map Mirroring}
\label{set-mirror}

We based the presentation of our synchronization approach on set reconciliation because it is a symmetric problem where both node use identical algorithms to compute identical types of messages. A related, asymmetric problem is that of a \defined{replica} node setting its locally stored set to that of a \defined{primary} node, utilizing similarity between the two initial sets to minimize the communication complexity. The approach of recursively exchanging fingerprints for subsets of decreasing size can be modified to solve this \defined{set mirroring} problem.

The primary node can run exactly the same protocol as that for such reconciliation. The replica node uses a slightly modified version. Whenever it receives an interval item set, it adds the received items to its local set as usual, but then it deletes all item it holds within that interval which were not part of the received interval item set. Whenever the replica node sends an interval item set, it sends an empty one.

The complexity analysis is identical to that of the set reconciliation protocol, the correctness argument is analogous: intervals with equal fingerprints are already correctly mirrored if no fingerprint collisions occurred, exchanging interval item sets correctly mirrors all items within that interval, and large intervals with non-equal fingerprints can be handled recursively because mirroring the partitions of a set results in mirroring the whole set.

Just as for reconciliation, maps can be mirrored by interpreting them as sets of key-value pairs. Mirroring maps has some interesting use cases, for example filesystems can be regarded as maps from paths to strings. The efficient creation of backups then becomes the problem of mirroring such a map onto a backup server that may already hold a similar, older backup. An equivalent problem is that of efficiently distributing source code updates from a server to clients which may hold old versions of the source code.
