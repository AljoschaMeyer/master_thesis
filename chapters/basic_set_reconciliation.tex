% !TEX root = ../main.tex

\newcommand{\examplefp}[1]{#1}
\newcommand{\fpa}[0]{\examplefp{144}}
\newcommand{\fpb}[0]{\examplefp{194}}
\newcommand{\fpc}[0]{\examplefp{240}}
\newcommand{\fpd}[0]{\examplefp{245}}
\newcommand{\fpe}[0]{\examplefp{76}}
\newcommand{\fpf}[0]{\examplefp{221}}
\newcommand{\fpg}[0]{\examplefp{224}}
\newcommand{\fph}[0]{\examplefp{65}}
\newcommand{\fpcd}[0]{\examplefp{229}}
\newcommand{\fpacd}[0]{\examplefp{117}}
\newcommand{\fpefgh}[0]{\examplefp{74}}
\newcommand{\fpbcdh}[0]{\examplefp{232}}
\newcommand{\fpzero}[0]{\examplefp{0}}

\newcommand{\examplea}[0]{a}
\newcommand{\exampleb}[0]{b}
\newcommand{\examplec}[0]{c}
\newcommand{\exampled}[0]{d}
\newcommand{\examplee}[0]{e}
\newcommand{\examplef}[0]{f}
\newcommand{\exampleg}[0]{g}
\newcommand{\exampleh}[0]{h}
\newcommand{\examplei}[0]{i}

\newcommand{\examplefpi}[3]{
  $\ifpmanual{#1}{#2}{\fp{#3}}$
}
\newcommand{\exampleiis}[3]{
\begin{tabular}{ c | c  | c }
{#1} & {#3} & {#2} \\ 
\end{tabular}
}

\tikzset{
fpi/.style={
  align=left,
  draw=black,
  fill=white
  }
}

\tikzset{
iis/.style={
  align=left,
  draw=black,
  fill=white
  }
}

\tikzset{
local/.style={
  }
}

\tikzstyle{edge} = [draw,thick,opacity=0.25]

In this chapter, we consider the set reconciliation protocol sketched in the introduction in greater detail.
We define the protocol in \cref{set-reconciliation-def}, prove its correctness in \cref{set-reconciliation-simple-correct}, and do a complexity analysis in \cref{set-reconciliation-complexity}.  \Cref{set-reconciliation-simple-optimizations} lists some optimizations which do not change the asymptotic complexity but which avoid some unnecessary work. We conclude the chapter with an example application in \cref{set-reconciliation-graphs}, briefly describing how the protocol can be applied to the synchronization of the hash graphs that arise e.g. in the context of distributed version control systems such as git~\cite{chacon2014pro}.

\section{Recursive Set Reconciliation}
\label{set-reconciliation-def}

The set reconciliation protocol assumes that there is a set $U$, a linear order $\preceq$ on $U$, a node $\mathcal{X}_0$ locally holding some $X_0 \subseteq U$, and a node $\mathcal{X}_1$ locally holding $X_1 \subseteq U$.
$\mathcal{X}_0$ and $\mathcal{X}_1$ exchange messages, a message consists of an arbitrary number of \defined{interval fingerprints} and \defined{interval item set}.
An interval fingerprint is a triple $\ifp{x}{y}{X_i}$ for $x, y \in U$, an interval item set a triple $\iis{x}{y}{S}$ for $x, y \in U, S \subseteq \interval{x}{y}{X_i}$.

Recall that $\fp{A}$ denotes the fingerprint for $A \subseteq U$, and that $\interval{x}{y}{A} \defeq \{a \in A | x \preceq a \prec y\}$.

When a node $\mathcal{X}_i$ receives a message, it performs the following actions:

\begin{itemize}
  \item For every interval item set \iis{x}{y}{S} in the message, all items in $S$ are added to the locally stored set $X_i$. The node then adds the interval item set $\iis{x}{y}{\interval{x}{y}{X_i} \setminus S}$ to the response, unless $\interval{x}{y}{X_i} \setminus S = \emptyset$.
  \item For every interval fingerprint $\ifp{x}{y}{X_j}$ in the message, it does one of following:
    \begin{caselist}
      \case[Equal Fingerprints] \label{def-fingerprint-eq} If $\fp{\interval{x}{y}{X_j}} = \fp{\interval{x}{y}{X_i}}$, nothing happens.
      \case[Recursion Anchor] \label{def-recursion-anchor} The node may add the interval item set $\iisnatural{x}{y}{X_i}$ to the response. If $\abs{\interval{x}{y}{X_j}} \leq 1$, it must do so.
      \case[Recurse] \label{def-recurse} Otherwise, the node selects $m_0 = x \prec m_1 \prec \ldots \prec m_k = y \in U$, $k \geq 2$ such that among all $\interval{m_0}{m_1}{X_i}$ for  $0 \leq l < k$ at least two intervals are non-empty. For all $0 \leq l < k$ it adds either the interval fingerprint $\ifp{m_l}{m_{l + 1}}{X_i}$ or the interval item set $\iisnatural{m_l}{m_{l + 1}}{X_i}$ to the response.
    \end{caselist}
  \item If the accumulated response is nonempty, it is sent to the other node. Otherwise, the protocol has terminated successfully.
\end{itemize}

To initiate reconciliation of an interval $[x, y)$, a node $\mathcal{X}_i$ sends a message containing solely the interval fingerprint $\ifp{x}{y}{X_i}$.

\Cref{simple-set-reconciliation-example} gives an example run of the protocol. TODO

\subsection{Observations}

Partitioning based on a total order allows the nodes to perform a limited form of queries, i.e. range queries. A node can ask for reconciliation within a certain interval, rather than over the whole universe.

If the universe $U$ is finite, the greatest element of the universe cannot be exchanged, since all ranges have an exclusive upper boundary. We will thus assume that for a universe $U$ of interest, nodes are actually using $\tilde{U} \defeq U \mathbin{\dot{\cup}} \top$ with $u \preceq \top$ for all $u \in U$.

If the universe $U$ is not finite, then there are items that require an arbitrary amount of bytes to encode. Since the protocol needs to transmit items to denote interval boundaries, no reasonably complexity guarantees can be given for infinite universes. We will thus assume $U$ to be finite and small enough that items can be reasonably encoded. This assumption is not very restrictive in practice because nodes can always synchronize hashes of items rather than the items themselves. The protocol can then be either followed by a phase where hashes of interest are transferred and anwered by the actual items, or the protocol can be made aware of the distinction and use hashes as interval boundaries while transmitting actual items for interval item sets.

When reconciling hashes in place of actual items, any semantically interesting order on the items would be replaced by an arbitrary order on the hashes. But rather than using just the hashes as interval boundaries, one can just as well add additional information. For example if the universe of interest consists of timestamped strings of arbitrary length, the interval boundaries can consist of timestamped hashes, ordered by timestamp first and using the numeric order on the hashes as a tiebreaker. \Cref{set-reconciliation-graphs} gives a more detailed example for utilizing this technique.

\section{Proof of Correctness}
\label{set-reconciliation-simple-correct}

\newcommand{\intcount}[1]{\mathit{count}_{#1}}

We now prove the correctness of the protocol. The protocol is correct if for all $x, y \in U$ both nodes eventually hold $\interval{x}{y}{X_i} \cup \interval{x}{y}{X_j}$ after a node $\mathcal{X}_i$ has received a message pertaining to the interval $[x, y)$.

\begin{caselist}
\case[Interval Item Set] \label{case-iis}  If the message contains the interval item set $\iisnatural{x}{y}{X_j}$, then $\mathcal{X}_i$ adds all items to its set, resulting in $\interval{x}{y}{X_i} \cup \interval{x}{y}{X_j}$ as desired. The other node then receives $\iis{x}{y}{\interval{x}{y}{X_i} \setminus \iisnatural{x}{y}{X_j}}$, ending up with $\interval{x}{y}{X_j} \cup (\iis{x}{y}{\interval{x}{y}{X_i} \setminus \iisnatural{x}{y}{X_j}}) = \interval{x}{y}{X_i} \cup \interval{x}{y}{X_j}$ as desired.

\case[Interval Fingerprint] \label{case-ifp} Otherwise, the message contains an interval fingerprint $\ifp{x}{y}{X_j}$.

\begin{caselist}
\case[Equal Fingerprints] If $\fp{\interval{x}{y}{X_j}} = \fp{\interval{x}{y}{X_i}}$, the protocol terminates immediately and no changes are performed by any node. Assuming no fingerprint collision occurred, $\interval{x}{y}{X_i} = \interval{x}{y}{X_j} = \interval{x}{y}{X_i} \cup \interval{x}{y}{X_j}$ as desired.

\case[Recursion Anchor] \label{case-ifp-anchor} If $\mathcal{X}_i$ adds the interval item set $\iisnatural{x}{y}{X_i}$, then \cref{case-iis} applies when the other node receives the response, with the roles reversed.

\case[Recurse] Let $\intcount{i} \defeq \abs{\interval{x}{y}{X_i}}$ and $\intcount{j} \defeq \abs{\interval{x}{y}{X_j}}$. $\intcount{j} \geq 2$, since otherwise $\mathcal{X}_j$ would have sent an item set for the interval. Similarly, $\intcount{i} \geq 2$, since we are not in \cref{case-ifp-anchor}. Thus, $\intcount{i} + \intcount{j} \geq 4$, and the protocol has already been proven correct for all cases where $\intcount{i} + \intcount{j} < 4$. 

We can thus finish the proof by induction on $\intcount{i} + \intcount{j}$, using the induction hypothesis that for all $x', y' \in U$ such that $\abs{\interval{x'}{y'}{X_i}} + \abs{\interval{x'}{y'}{X_j}} < \intcount{i} + \intcount{j}$ the protocol correctly reconciles $\interval{x'}{y'}{X_i}$ and $\interval{x'}{y'}{X_j}$.

$\mathcal{X}_i$ partitions the interval into $k \geq 2$ subintervals, of which at least two must be nonempty.
Thus $\abs{\interval{m_l}{m_{l + 1}}{X_i}} < \intcount{i}$ for all $0 \leq l < k$.
Furthermore, $\interval{m_l}{m_{l + 1}}{X_j} \subseteq \interval{x}{y}{X_j}$ and thus $\abs{\interval{m_l}{m_{l + 1}}{X_j}} \leq \abs{\interval{x}{y}{X_j}}$, so overall we have $\abs{\interval{m_l}{m_{l + 1}}{X_i}} + \abs{\interval{m_l}{m_{l + 1}}{X_j}} < \intcount{i} + \intcount{j}$ and can apply the induction hypothesis to conclude that every subinterval is correctly reconciled. Since the subintervals partition the original interval, the original interval is then correctly reconciled as well.
\end{caselist}
\end{caselist}

\section{Complexity Analysis}
\label{set-reconciliation-complexity}

The protocol gives nodes the freedom to respond to an interval fingerprint with an interval item set even if the interval fingerprint is arbitrarily large. For a meaningful complexity analysis we need to restrict the behavior of the node, a realistic modus operandi is for a node to send an interval item set whenever it holds a number of items less than or equal to some threshold $t \in \mathbb{N}, t \geq 1$ within the interval. Higher choices for $t$ reduce the number of roundtrips, but increase the probability that a items is being sent even though the other node already holds it.

A node is similarly given freedom over the number of subintervals into which to split an interval when recursing. We will assume a node always splits into at most $b \in \mathbb{N}, b \geq 2$ subintervals. As with $t$, higher numbers reduce the number of roundtrips at the cost of potentially sending items or fingerprints that did not need sending.

Because we want to analyze not only the worst-case complexity but also the complexity depending on the similarity between the two sets held by the participating nodes, we define some rather fine-grained instance size parameters: $n_0$ and $n_1$ denote the number of items held by $\mathcal{X}_0$ and $\mathcal{X}_1$ respectively. We let $n \defeq n_0 + n_1$, $n_{min} \defeq \mathit{min}(n_0, n_1)$, $n_{max} \defeq \mathit{max}(n_0, n_1)$, $n_{\cap} \def \abs{\interval{x}{y}{X_0} \cap \interval{x}{y}{X_1}}$, $n_{\cup} \def \abs{\interval{x}{y}{X_0} \cup \interval{x}{y}{X_1}}$ and $n_{\triangle} \defeq \abs{(\interval{x}{y}{X_0} \cup \interval{x}{y}{X_1}) \setminus (\interval{x}{y}{X_0} \cap \interval{x}{y}{X_1})}$. TODO remove those that are not needed

\subsection{Preliminary Observations}

A helpful observation for the following analysis is that the interval fingerprints that are being exchanged during a protocol run form a rooted tree where every vertex has at most $b$ children. When a leaf of the tree is reached, an exchange of interval item sets follows. Equal fingerprints can also cut the tree short, but for the following worst-case analysis we will assume this does not occur.

Node $\mathcal{X}_i$ can branch at most $\ceil{\mathit{log}_{b}(n_i)}$ times, so the overall height of the tree is bounded by $2 \cdot\ceil{\mathit{log}_{b}(n_{min})}$. The number of vertices of such a complete tree of height $h$ is at most $\sum_{i=0}^{h} b^{i} = \frac{b^{h} - 1}{b - 1}$. For $h \leq 2 \cdot\ceil{\mathit{log}_{b}(n_{min})}$, $\frac{b^{h} - 1}{b - 1} \leq 2 \cdot 2 \cdot n_{min} \leq 2n \in \complexity{n}$.

The parameter $t$ determines when recursion is cut off, and thus influences the height of the tree. For $t = 1$, the protocol recurses as far as possible. For $t = b$, the last level of recursion is cut off, for $t = b^2$ the last two levels, and so on. Overall, the height of the tree is reduced by $\floor{\mathit{log}_{b}(t)}$.

\subsection{Communication Rounds}

The number of communication rounds clearly corresponds to the height of the tree, plus $2$ to account for the exchange of interval item sets, so the worst-case is $2 + 2 \cdot\ceil{\mathit{log}_{b}(n_{min})} - \floor{\mathit{log}_{b}(t)} \in \complexity{\mathit{log}_{b}(n)}$. This number cannot be bounded by $n_{\triangle}$, as witnessed by problem instances where one node is missing exactly one item compared to the other node. In such an instance, $b - 1$ branches in each recursion step result in equal fingerprints, but the one branch that does continue reaches the recursion anchor only after the full number of rounds. See \cref{fig:worst-rounds} for an example.

\begin{figure*}
$X_0 \defeq \{\examplea, \exampleb, \examplec, \exampled, \examplee, \exampleg, \exampleh \}$
\hfill
$X_1 \defeq \{\examplea, \exampleb, \examplec, \exampled, \examplee, \examplef, \exampleg, \exampleh \}$

\begin{scaletikzpicturetowidth}{\textwidth}
\begin{tikzpicture}[scale=\tikzscale, font=\tiny]
	\pgfdeclarelayer{background}
	\pgfdeclarelayer{foreground}
	\pgfsetlayers{background,main,foreground}
	
	\begin{pgfonlayer}{main}
		%vertices
		\node (vroot) at (0, 1) [fpi] {\examplefpi{\examplea}{\examplei}{\{\examplea, \exampleb, \examplec, \exampled, \examplee, \examplef, \exampleg, \exampleh\}}};

		\node (v00) at (-4, -0) [fpi] {\examplefpi{\examplea}{\examplee}{\{\examplea, \exampleb, \examplec, \exampled\}}};
		\node (v01) at (4, -0) [fpi] {\examplefpi{\examplee}{\examplei}{\{\examplee, \exampleg, \exampleh\}}};

                \node (v10) at (2, -1) [fpi] {\examplefpi{\examplee}{\exampleg}{\{\examplee, \examplef\}}};
                \node (v11) at (6, -1) [fpi] {\examplefpi{\exampleg}{\examplei}{\{\exampleg, \exampleh\}}};

                \node (v20) at (2, -2) [iis] {\exampleiis{\examplee}{\exampleg}{\{\examplee\}}};

                \node (v30) at (2, -3) [iis] {\exampleiis{\examplee}{\exampleg}{\{\examplef\}}};

		%edges
                \draw (vroot) edge[edge] (v00);
                \draw (vroot) edge[edge] (v01);

		\draw (v01) edge[edge] (v10);
		\draw (v01) edge[edge] (v11);

		\draw (v10) edge[edge] (v20);
		
		\draw (v20) edge[edge] (v30);
	\end{pgfonlayer}
	
	\begin{pgfonlayer}{background}
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](8, 1) -- (-8, 1);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](-8, -0) -- (8, -0);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](8, -1) -- (-8, -1);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](-8, -2) -- (8, -2);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](8, -3) -- (-8, -3);
	\end{pgfonlayer}
\end{tikzpicture}
\end{scaletikzpicturetowidth}

\caption{An example run of the protocol that takes the greatest possible number of rounds even though $n_{\triangle} = 1$. $b \defeq 2, t \defeq 1$.}

\label{fig:worst-rounds}

\end{figure*}

\subsection{Communication Complexity}

The total number of bits that needs to be transmitted during a protocol run is proportional to the number of vertices in the tree. Every interval fingerprint consists of two items and one fingerprint, so assuming $U$ is finite this lies in $\complexity{1}$. Since there are at most $2n$ vertices in the tree, the interval fingerprints require at most $\complexity{n}$ bits to be communicated.

The exchange of interval item sets consists in the worst case of exchanging every item using $\ceil{\frac{n}{t}}$ interval item sets. An interval item set needs to transmit two items to encode the boundaries, as well as the items themselves, which lies in $\complexity{1}$ per interval item set. All interval item sets together thus amount to another $\complexity{n}$, leading to a total of $\complexity{n}$ bits being transmitted in the worst case.

\Cref{fig:worst-bytes} shows a worst-case example in which the tree of height $h \defeq \mathit{log}_{b}(2 \cdot n_{min})$ has all $\frac{b^{h} - 1}{b - 1}$ vertices. 

TODO bound complexity by difference, also average case?

\begin{figure*}
$X_0 \defeq \{\examplea, \examplec, \examplee, \exampleg \}$
\hfill
$X_1 \defeq \{\examplea, \exampleb, \examplec, \exampled, \examplee, \examplef, \exampleg, \exampleh\}$

\begin{scaletikzpicturetowidth}{\textwidth}
\begin{tikzpicture}[scale=\tikzscale, font=\tiny]
	\pgfdeclarelayer{background}
	\pgfdeclarelayer{foreground}
	\pgfsetlayers{background,main,foreground}
	
	\begin{pgfonlayer}{main}
		%vertices
		\node (vroot) at (0, 1) [fpi] {\examplefpi{\examplea}{\examplei}{\{\examplea, \exampleb, \examplec, \exampled, \examplee, \examplef, \exampleg, \exampleh\}}};

		\node (v00) at (-4, -0) [fpi] {\examplefpi{\examplea}{\examplee}{\{\examplea, \examplec\}}};
		\node (v01) at (4, -0) [fpi] {\examplefpi{\examplee}{\examplei}{\{\examplee, \exampleg\}}};

                \node (v10) at (-6, -1) [fpi] {\examplefpi{\examplea}{\examplec}{\{\examplea, \exampleb\}}};
                \node (v11) at (-2, -1) [fpi] {\examplefpi{\examplec}{\examplee}{\{\examplec, \exampled\}}};
                \node (v12) at (2, -1) [fpi] {\examplefpi{\examplee}{\exampleg}{\{\examplee, \examplef\}}};
                \node (v13) at (6, -1) [fpi] {\examplefpi{\exampleg}{\examplei}{\{\exampleg, \exampleh\}}};

                \node (v20) at (-6, -2) [iis] {\exampleiis{\examplea}{\examplec}{\{\examplea\}}};
                \node (v21) at (-2, -2) [iis] {\exampleiis{\examplec}{\examplee}{\{\examplec\}}};
                \node (v22) at (2, -2) [iis] {\exampleiis{\examplee}{\exampleg}{\{\examplee\}}};
                \node (v23) at (6, -2) [iis] {\exampleiis{\exampleg}{\examplei}{\{\exampleg\}}};

                \node (v30) at (-6, -3) [iis] {\exampleiis{\examplea}{\examplec}{\{\exampleb\}}};
                \node (v31) at (-2, -3) [iis] {\exampleiis{\examplec}{\examplee}{\{\exampled\}}};
                \node (v32) at (2, -3) [iis] {\exampleiis{\examplee}{\exampleg}{\{\examplef\}}};
                \node (v33) at (6, -3) [iis] {\exampleiis{\exampleg}{\examplei}{\{\exampleh\}}};
		%edges
                \draw (vroot) edge[edge] (v00);
                \draw (vroot) edge[edge] (v01);

		\draw (v00) edge[edge] (v10);
		\draw (v00) edge[edge] (v11);
		\draw (v01) edge[edge] (v12);
		\draw (v01) edge[edge] (v13);

		\draw (v10) edge[edge] (v20);
		\draw (v11) edge[edge] (v21);
		\draw (v12) edge[edge] (v22);
		\draw (v13) edge[edge] (v23);

		\draw (v20) edge[edge] (v30);
		\draw (v21) edge[edge] (v31);
		\draw (v22) edge[edge] (v32);
		\draw (v23) edge[edge] (v33);
	\end{pgfonlayer}
	
	\begin{pgfonlayer}{background}
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](8, 1) -- (-8, 1);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](-8, -0) -- (8, -0);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](8, -1) -- (-8, -1);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](-8, -2) -- (8, -2);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](8, -3) -- (-8, -3);
	\end{pgfonlayer}
\end{tikzpicture}
\end{scaletikzpicturetowidth}

\caption{An example run of the protocol that requires transmitting the maximum amount of bytes. $b \defeq 2, t \defeq 1$.}

\label{fig:worst-bytes}
\end{figure*}

\subsection{Computational Complexity}

We now analyze the computational cost incurred by a single communication round, i.e. computing the response to a message. This includes both fingerprint comparisons as well as locating the items to transmit. We do however assume that an auxiliary data structure is available to help with this computation, e.g. the a fingerprint tree structure presented in \cref{TODO}. We exclude both space usage and maintenance cost for this data structure from the per-round complexity.

We will assume that transferring an item as part of an interval item set requires $\complexity{1}$ time and space. The relevant computational overhead per communication round thus consists of computing $\fp{\interval{x}{y}{X_i}}$ for every received interval fingerprint $\ifp{x}{y}{X_j}$, as well as partitioning $\interval{x}{y}{X_i}$ in case of a mismatch and computing the fingerprints over all subintervals. These computations can be performed independently for all received interval fingerprints, so in particular they can be performed sequentially, reusing space. The overall space complexity of the per-round computations is equal to that of the computations for a single interval fingerprint.

A naive approach is to query the auxiliary data structure for each received interval fingerprint individually. The maximum amount of queries is upper-bounded by $n$, it is certainly impossible to receive more than $n$ interval fingerprints within a single communication round. Unfortunately, the greatest possible number of interval fingerprints within a single round corresponds to the number of leaves in the recursion tree, which is in $\complexity{n}$. The auxiliary data structure requires $\complexity{\mathit{log}(n)}$ time, leading to an overall $\complexity{n \cdot \mathit{log}(n)}$.

We can bring this down to $\complexity{\mathit{log}(n) + n_{\triangle}}$ by augmenting the auxiliary data structure with parent-pointers to allow efficient in-order traversal, and by memoizing some intermediate fingerprint computation results. TODO (write fingerprint chapter first)

\section{Generic Optimizations}
\label{set-reconciliation-simple-optimizations}

We now give a list of optimizations which do not impact the overall complexity analysis, but which do improve on some constant factors.

\subsection{Non-Uniform Partitions}

When partitioning an interval into subintervals, the protocol does not specify where exactly to place the boundaries. Splitting into partitions of roughly equal sizes makes a lot of sense if new data could arise anywhere within the linear order with equal probability. Is however the items are likely to fall within certain ranges of the order, it can be more efficient to use more fine-grained partitions within those regions. If for example items are sorted by timestamp, and new items are expected to be propagated to every node in the system within a couple of seconds, then all the items that are older than ten seconds can be confortably lumped together in a large interval.

opts:

- non-uniform splits
- superset rather than equality
- utilize lower boundary
- ecoding tricks
  - omit adjacent boundaries
  - merge adjacent intervals
  -  item sets without boundaries?

%\subsection{Utilizing Interval Boundaries}
%\label{utilizing-boundaries}
%
%The next two optimizations stem from the fact that roughly half of all intervals include their lower boundary. When a node receives an interval fingerprint starting at some $x \in U$ and knows that the other node holds that $x$, it can simply add $x$ to its own set and $x$ can be excluded from any further reconciliation effort.
%
%An optimization that can be applied independent of $U$ and $\preceq$ is to introduce \defined{lower singleton intervals}, ranging from $x$ to $y$ and containing no item but $x$, denoted as $\ifpsingle{x}{y}$. When $\mathcal{X}_i$ receives a lower singleton interval $\ifpsingle{x}{y}$, it can reply with all items $u$ such that $x \prec u \prec y$. If $x \notin X_i$, it adds it to the set, otherwise no further action is necessary. This optimization shaves off one communication round in \cref{two-singletons} because $\mathcal{X}_1$ responds with $\ifpsingle{u1}{y}$ rather than $\ifpmanual{u_1}{y}{\fp{u_1}}$, thus finishing reconciliation in at most one more communication round.00
%
%In order to efficiently leverage the knowledge that some interval of size at least two contains its lower boundary, $\preceq$ must be antidense:
%
%\begin{definition}
%Let $U$ be a set and $\preceq$ be a linear order on $u$. We call $\preceq$ \defined{antidense} if for all $x \in U$, if there exists $y \in U$ such that $x \prec y$, then there exists a least such element, denoted as $\successor{x}$.
%\end{definition}
%
%If $\preceq$ is antidense, we can introduce \defined{least-containing intervals}, ranging from $x$ to $y$ and guaranteed to contain $x$ and some other items whose fingerprint is $f$, denoted $\ifpcontain{x}{y}{f}$ (this is just a notation, $\fp{x}$ does not have to be transmitted). A node receiving a least-containing interval $\ifpcontain{x}{y}{f}$ reacts as if it received the item $x$ and the regular interval fingerprint $\ifpmanual{\successor{x}}{y}{f}$. Furthermore, whenever $\mathcal{X}_i$ sends a regular interval fingerprint $\ifp{x}{y}{X_i}$ and then receives a regular interval fingerprint $\ifp{x}{m}{X_j}$, neither node has item $x$, so $\mathcal{X}_i$ can act as if it received $\ifp{\successor{x}}{y}{X_j}$ instead.
%In both of these cases, if $\successor{x}$ is not defined, i.e. $x$ is the maximal element of the order, the notes merely act as if they just reconciled $x$ and do not perform any further work.
%
%This approach explicitly adds a single bit of information to each interval, namely whether the lower boundary is contained or not. A different approach is to implicitly distinguish between intervals that definitely contain the lower boundary, i.e. the greater of the two intervals obtained after a split, and intervals that may or may not contain their lower boundary, i.e. all other intervals. In this setting, sending and receiving a regular interval with the same lower boundary does not imply that the other node does not hold that item.
%
%Utilizing this information can even be done for universes with a non-antidense order, by introducing intervals which exclude both their boundaries: $\intervalx{x}{y}{A} \defeq \{a \in A | x \prec a \prec y\}$. When a node receives an interval $\interval{m}{y}{X_i}$ which is a greater interval obtained from a split, it reacts as if it received the item $x$ and the fingerprint over the interval $\ifpmanual{m}{y}{\intervalx{m}{y}{X_i}}$.
%
%\subsection{Bounded Boundaries}
%
%The boundaries of intervals come from the universe $U$ and need to be transmitted. If $U$ contains arbitrarily large elements, e.g. $U \defeq \{0, 1\}^{\ast}$, the protocol cannot uphold any reasonable complexity guarantees. The solution is to employ indirection, for example by hashing the items from $U$ and then comparing the hashes lexicographically rather than using any order on $U$. After the protocol has terminated, each node holds the hashes of the items it is missing.
%
%As a last phase, the nodes can then exchange those lists of hashes and answer with the items thus requested by the other node. Alternatively, the items could be retrieved from some content-addressable storage substrate. Both of these solutions add additional roundtrips to the reconciliation. A more efficient solution is to make the protocol aware of the difference between the hashes being used for interval delimiting and the actual items of interest. Whenever the protocol determines that an item needs to be transmitted, the node transmits the actual item rather than the hash.
%
%If the protocol is made aware of the difference and inlines items, most of the optimizations from \cref{utilizing-boundaries} become inapplicable, since knowing that the other node holds an item hashing to some lower boundary of an interval is not the same as obtaining that item. The only optimization in the same spirit that can be applied as the following: if a node $\mathcal{X}_i$ receives an interval fingerprint $\ifpmanual{m}{y}{\fp{m}}$, it can act as if it received an interval containing only $m$ and it additionally sends all items in $\intervalx{m}{y}{X_i}$.
%
%The interval boundaries do not necessarily have to be only the hashes of the items, additional information can be added so that the order on the boundaries exhibit similarity with some order on the items. Hashing has to be involved though in order to map the infinite universe to a finite set of boundaries with a low probability of collisions.

\section{Reconciling Hash Graphs}
\label{set-reconciliation-graphs}
