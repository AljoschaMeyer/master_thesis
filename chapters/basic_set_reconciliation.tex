% !TEX root = ../main.tex

\newcommand{\examplefp}[1]{#1}
\newcommand{\fpa}[0]{\examplefp{144}}
\newcommand{\fpb}[0]{\examplefp{194}}
\newcommand{\fpc}[0]{\examplefp{240}}
\newcommand{\fpd}[0]{\examplefp{245}}
\newcommand{\fpe}[0]{\examplefp{76}}
\newcommand{\fpf}[0]{\examplefp{221}}
\newcommand{\fpg}[0]{\examplefp{224}}
\newcommand{\fph}[0]{\examplefp{65}}
\newcommand{\fpcd}[0]{\examplefp{229}}
\newcommand{\fpacd}[0]{\examplefp{117}}
\newcommand{\fpefgh}[0]{\examplefp{74}}
\newcommand{\fpbcdh}[0]{\examplefp{232}}
\newcommand{\fpzero}[0]{\examplefp{0}}

\newcommand{\examplea}[0]{a}
\newcommand{\exampleb}[0]{b}
\newcommand{\examplec}[0]{c}
\newcommand{\exampled}[0]{d}
\newcommand{\examplee}[0]{e}
\newcommand{\examplef}[0]{f}
\newcommand{\exampleg}[0]{g}
\newcommand{\exampleh}[0]{h}
\newcommand{\examplei}[0]{i}

\newcommand{\examplefpi}[3]{
  $\ifpmanual{#1}{#2}{\fp{#3}}$
}
\newcommand{\exampleiis}[3]{
\begin{tabular}{ c | c  | c }
{#1} & {#3} & {#2} \\ 
\end{tabular}
}

\tikzset{
fpi/.style={
  align=left,
  draw=black,
  fill=white
  }
}

\tikzset{
iis/.style={
  align=left,
  draw=black,
  fill=white
  }
}

\tikzset{
local/.style={
  }
}

\tikzstyle{edge} = [draw,thick,opacity=0.25]

In this chapter, we consider the set reconciliation protocol sketched in the introduction in greater detail.
We define an unoptimized but simple version of the protocol in \cref{set-reconciliation-simple-def}, and we prove its correctness in \cref{set-reconciliation-simple-correct}. \Cref{set-reconciliation-simple-optimizations} lists optimizations which eliminate unnecessary work from the protocol. We then define the proper set reconciliation protocol in \cref{set-reconciliation-def} and  do a complexity analysis in \cref{set-reconciliation-complexity}. We conclude the chapter with an example application in \cref{set-reconciliation-simple-graphs}, briefly describing how the protocol can be applied to the synchronization of the hash graphs that arise e.g. in the context of distributed version control systems such as git~\cite{chacon2014pro}.

\section{Recursive Set Reconciliation}

The set reconciliation protocol assumes that there is a set $U$, a linear order $\preceq$ on $U$, a node $\mathcal{X}_0$ locally holding some $X_0 \subseteq U$, and a node $\mathcal{X}_1$ locally holding $X_1 \subseteq U$.
$\mathcal{X}_0$ and $\mathcal{X}_1$ exchange messages, a message consists of an arbitrary number of \defined{interval fingerprints} and \defined{interval item set}.
An interval fingerprint is a triple $\ifp{x}{y}{X_i}$ for $x, y \in U$, an interval item set a triple $\iis{x}{y}{S}$ for $x, y \in U, S \subseteq \interval{x}{y}{X_i}$.

Recall that $\fp{A}$ denotes the fingerprint for $A \subseteq U$, and that $\interval{x}{y}{A} \defeq \{a \in A | x \preceq a \prec y\}$.

When a node $\mathcal{X}_i$ receives a message, it performs the following actions:

\begin{itemize}
  \item For every interval item set \iis{x}{y}{S} in the message, all items in $S$ are added to the locally stored set $X_i$. The node then adds the interval item set $\iis{x}{y}{\interval{x}{y}{X_i} \setminus S}$ to the response, unless $\interval{x}{y}{X_i} \setminus S = \emptyset$.
  \item For every interval fingerprint $\ifp{x}{y}{X_j}$ in the message, it does one of following:
    \begin{caselist}
      \case[Equal Fingerprints] \label{def-fingerprint-eq} If $\fp{\interval{x}{y}{X_j}} = \fp{\interval{x}{y}{X_i}}$, nothing happens.
      \case[Recursion Anchor] \label{def-recursion-anchor} The node may add the interval item set $\iisnatural{x}{y}{X_i}$ to the response. If $\abs{\interval{x}{y}{X_j}} \leq 1$, it must do so.
      \case[Recurse] \label{def-recurse} Otherwise, the node selects $m_0 = x \prec m_1 \prec \ldots \prec m_k = y \in U$, $k \geq 2$ such that among all $\interval{m_0}{m_1}{X_i}$ for  $0 \leq l < k$ at least two intervals are non-empty. For all $0 \leq l < k$ it adds either the interval fingerprint $\ifp{m_l}{m_{l + 1}}{X_i}$ or the interval item set $\iisnatural{m_l}{m_{l + 1}}{X_i}$ to the response.
    \end{caselist}
  \item If the accumulated response is nonempty, it is sent to the other node. Otherwise, the protocol has terminated successfully.
\end{itemize}

To initiate reconciliation of an interval $[x, y)$, a node $\mathcal{X}_i$ sends a message containing solely the interval fingerprint $\ifp{x}{y}{X_i}$.

\Cref{simple-set-reconciliation-example} gives an example run of the protocol.

%\section{Simple Recursive Set Reconciliation}
%\label{set-reconciliation-simple-def}
%
%The set reconciliation protocol assumes that there is a set $U$, a linear order $\preceq$ on $U$, a node $\mathcal{X}_0$ locally holding some $X_0 \subseteq U$, and a node $\mathcal{X}_1$ locally holding $X_1 \subseteq U$.
%$\mathcal{X}_0$ and $\mathcal{X}_1$ exchange messages, a message consists of an arbitrary number of \defined{interval fingerprints} and \defined{items}.
%An interval fingerprint is a triple $\ifp{x}{y}{X_i}$ for $x, y \in U$, an item is simply some $x \in U$.
%
%Recall that $\fp{A}$ denotes the fingerprint for $A \subseteq U$, and that $\interval{x}{y}{A} \defeq \{a \in A | x \preceq a \prec y\}$.
%
%When a node $\mathcal{X}_i$ receives a message, it performs the following actions:
%
%\begin{itemize}
%  \item For every item in the message, the item is added to the locally stored set $X_i$.
%  \item For every interval fingerprint $\ifp{x}{y}{X_j}$ in the message, it does one of following:
%    \begin{caselist}
%      \case[Equal Fingerprints] \label{def-fingerprint-eq}  If $\fp{\interval{x}{y}{X_j}} = \fp{\interval{x}{y}{X_i}}$, nothing happens.
%      \case[Receiving Empty] If $\fp{\interval{x}{y}{X_j}} = \neutraladd$, it adds all items in $\interval{x}{y}{X_i}$ to the response.
%      \case[Sending Empty] \label{def-x1-empty} If $\fp{\interval{x}{y}{X_j}} \neq \neutraladd = \fp{\interval{x}{y}{X_i}}$, it adds the interval fingerprint $\ifp{x}{y}{X_i} = \ifpmanual{x}{y}{\neutraladd}$ to the response.
%      \case[Recursive] \label{def-recursive} Otherwise, it finds some middle item $m \in X_i$ that equally partitions the items of $X_i$ within the interval, i.e. $m$ is chosen such that $-1 \leq \abs{\{a \in X_i | x \preceq a \prec m\}} - \abs{\{b \in X_i | m \preceq b \prec y\}} \leq 0$. It then adds the interval fingerprints $\ifp{x}{m}{X_i}$ and $\ifp{m}{y}{X_i}$ to the response.
%    \end{caselist}
%  \item If the accumulated response is nonempty, it is sent to the other node.
%\end{itemize}
%
%To initiate reconciliation of an interval, a node sends a message consisting solely of its interval fingerprint of the interval to reconcile.
%
%\Cref{simple-set-reconciliation-example} gives an example run of the protocol.
%
%\begin{figure*}
%\newcommand{\examplefp}[1]{#1}
%\newcommand{\fpa}[0]{\examplefp{144}}
%\newcommand{\fpb}[0]{\examplefp{194}}
%\newcommand{\fpc}[0]{\examplefp{240}}
%\newcommand{\fpd}[0]{\examplefp{245}}
%\newcommand{\fpe}[0]{\examplefp{76}}
%\newcommand{\fpf}[0]{\examplefp{221}}
%\newcommand{\fpg}[0]{\examplefp{224}}
%\newcommand{\fph}[0]{\examplefp{65}}
%\newcommand{\fpcd}[0]{\examplefp{229}}
%\newcommand{\fpacd}[0]{\examplefp{117}}
%\newcommand{\fpefgh}[0]{\examplefp{74}}
%\newcommand{\fpbcdh}[0]{\examplefp{232}}
%\newcommand{\fpzero}[0]{\examplefp{0}}
%
%\newcommand{\examplea}[0]{a}
%\newcommand{\exampleb}[0]{b}
%\newcommand{\examplec}[0]{c}
%\newcommand{\exampled}[0]{d}
%\newcommand{\examplee}[0]{e}
%\newcommand{\examplef}[0]{f}
%\newcommand{\exampleg}[0]{g}
%\newcommand{\exampleh}[0]{h}
%\newcommand{\examplei}[0]{i}
%
%\newcommand{\examplefpi}[5]{
%\begin{minipage}{3.2cm}
%  $\ifpmanual{#2}{#3}{\fp{\interval{#2}{#3}{X_{#1}}}} = \linebreak \ifpmanual{#2}{#3}{\fp{#5}} = \linebreak \ifpmanual{#2}{#3}{#4}$
%\end{minipage}
%}
%\newcommand{\exampleitems}[1]{$#1$}
%
%\begin{center}
%\begin{tabular}{ c || c | c | c | c | c | c | c | c | c }
%item & \examplea & \exampleb & \examplec & \exampled & \examplee & \examplef & \exampleg & \exampleh & \examplei \\
%\hline
%$\fp{item}$ & \fpa & \fpb & \fpc & \fpd & \fpe & \fpf & \fpg & \fph & \fpzero \\ 
%\end{tabular}
%\end{center}
%
%$X_0 \defeq \{\exampleb, \examplec, \exampled, \exampleh \}$
%\hfill
%$X_1 \defeq \{\examplea, \examplec, \exampled, \examplee, \examplef, \exampleg, \exampleh \}$
%
%
%\tikzset{
%fpi/.style={
%  %draw=none,
%  %inner sep=0pt,
%  %text width=100pt,
%  %minimum size=36pt,
%  align=left,
%  draw=black,
%  fill=white
%  }
%}
%
%\tikzset{
%items/.style={
%  %draw=none,
%  %inner sep=0pt,
%  %text width=100pt,
%  %minimum size=36pt,
%  shape=ellipse,
%  align=left,
%  draw=black,
%  fill=white
%  }
%}
%
%\tikzset{
%local/.style={
%  %draw=none,
%  %inner sep=0pt,
%  %text width=100pt,
%  %minimum size=36pt,
%%  shape=ellipse,
%%  align=left,
%%  draw=black,
%%  fill=white
%  }
%}
%
%\tikzstyle{edge} = [draw,thick,opacity=0.25]
%
%\begin{tikzpicture}[xscale=1.25,yscale=2.25,font=\footnotesize]
%	%\useasboundingbox (0,0) rectangle (17,5);
%	\pgfdeclarelayer{background}
%	\pgfdeclarelayer{foreground}
%	\pgfsetlayers{background,main,foreground}
%	
%	\begin{pgfonlayer}{main}
%		%vertices
%		\node (v60) at (6,-0) [fpi] {\examplefpi{0}{\examplea}{\examplei}{\fpbcdh}{\{\exampleb, \examplec, \exampled, \exampleh\}}};
%
%                \node (v31) at (3,-1) [fpi] {\examplefpi{1}{\examplea}{\examplee}{\fpacd}{\{\examplea, \examplec, \exampled\}}};
%                \node (v91) at (9,-1) [fpi] {\examplefpi{1}{\examplee}{\examplei}{\fpefgh}{\{\examplee, \examplef, \exampleg, \exampleh\}}};
%
%                \node (v12) at (1,-2) [fpi] {\examplefpi{0}{\examplea}{\examplec}{\fpb}{\{\exampleb\}}};
%                \node (v42) at (4,-2) [fpi] {\examplefpi{0}{\examplec}{\examplee}{\fpcd}{\{\examplec, \exampled\}}};
%                \node (v72) at (7,-2) [fpi] {\examplefpi{0}{\examplee}{\exampleh}{\fpzero}{\emptyset}};
%                \node (v102) at (10,-2) [fpi] {\examplefpi{0}{\exampleh}{\examplei}{\fph}{\{\exampleh\}}};
%
%                \node (v03) at (0,-3) [fpi] {\examplefpi{1}{\examplea}{\examplea}{\fpzero}{\emptyset}};
%                \node (v23) at (4,-3) [fpi] {\examplefpi{1}{\examplea}{\examplec}{\fpa}{\{\examplea\}}};
%                \node (v73) at (7,-3) [items] {\exampleitems{\{\examplee, \examplef, \exampleg\}}};
%
%                \node (v04) at (0,-4) [items] {\exampleitems{\emptyset}};
%                \node (v14) at (2,-4) [fpi] {\examplefpi{0}{\examplea}{\exampleb}{\fpzero}{\emptyset}};
%                \node (v34) at (6,-4) [fpi] {\examplefpi{0}{\exampleb}{\examplec}{\fpb}{\{\exampleb\}}};
%
%                \node (v15) at (2,-5) [items] {\exampleitems{\{\examplea\}}};
%                \node (v35) at (6,-5) [fpi] {\examplefpi{1}{\exampleb}{\examplec}{\fpzero}{\emptyset}};
%
%                \node (v36) at (6,-6) [items] {\exampleitems{\{\exampleb\}}};
%
%                \node (x00) at (-3, -0) [local] {
%\begin{minipage}{6cm}
%\begin{center}
%\begin{tabular}{ || c  c  c  c || }
%\hline
%\exampleb & \examplec & \exampled & \exampleh \\ 
%\hline
%\end{tabular}
%\end{center}
%\end{minipage}
%};
%
%                \node (x01) at (-3, -1) [local] {
%\begin{minipage}{6cm}
%\begin{center}
%\begin{tabular}{ || c  c  c |  c || }
%\hline
%\exampleb & \examplec & \exampled & \exampleh \\ 
%\hline
%\end{tabular}
%\end{center}
%\end{minipage}
%};
%
%                \node (x02) at (-3, -2) [local] {
%\begin{minipage}{6cm}
%\begin{center}
%\begin{tabular}{ || c | c  c || c |  c || }
%\hline
%\exampleb & \examplec & \exampled & & \exampleh \\ 
%\hline
%\end{tabular}
%\end{center}
%\end{minipage}
%};
%
%                \node (x03) at (-3, -3) [local] {
%\begin{minipage}{6cm}
%\begin{center}
%\begin{tabular}{ || c | c || c  c | c  c  c |  c || }
%\hline
% & \exampleb & \examplec & \exampled & \examplee & \examplef & \exampleg & \exampleh \\ 
%\hline
%\end{tabular}
%\end{center}
%\end{minipage}
%};
%
%                \node (x03) at (-3, -4) [local] {
%\begin{minipage}{6cm}
%\begin{center}
%\begin{tabular}{ || c | c  c || c | c | c ||  c || }
%\hline
%\exampleb & \examplec & \exampled & \examplee & \examplef & \exampleg & \exampleh \\ 
%\hline
%\end{tabular}
%\end{center}
%\end{minipage}
%};
%
%		%edges
%		\draw (v60) edge[edge] (v31);
%		\draw (v60) edge[edge] (v91);
%
%		\draw (v31) edge[edge] (v12);
%		\draw (v31) edge[edge] (v42);
%		\draw (v91) edge[edge] (v72);
%		\draw (v91) edge[edge] (v102);
%		
%		\draw (v12) edge[edge] (v03);
%		\draw (v12) edge[edge] (v23);
%		\draw (v72) edge[edge] (v73);
%
%		\draw (v03) edge[edge] (v04);
%		\draw (v23) edge[edge] (v14);
%		\draw (v23) edge[edge] (v34);
%
%		\draw (v14) edge[edge] (v15);
%		\draw (v34) edge[edge] (v35);
%
%                \draw (v35) edge[edge] (v36);
%	\end{pgfonlayer}
%	
%	\begin{pgfonlayer}{background}
%		\draw[-{Triangle[width=40pt,length=20pt,color=gray]}, line width=20pt, color=gray](-1,0) -- (11, 0);
%                \draw[-{Triangle[width=40pt,length=20pt,color=gray]}, line width=20pt, color=gray](11,-1) -- (-1, -1);
%                \draw[-{Triangle[width=40pt,length=20pt,color=gray]}, line width=20pt, color=gray](-1,-2) -- (11, -2);
%                \draw[-{Triangle[width=40pt,length=20pt,color=gray]}, line width=20pt, color=gray](11,-3) -- (-1, -3);
%                \draw[-{Triangle[width=40pt,length=20pt,color=gray]}, line width=20pt, color=gray](-1,-4) -- (11, -4);
%                \draw[-{Triangle[width=40pt,length=20pt,color=gray]}, line width=20pt, color=gray](11,-5) -- (-1, -5);
%                \draw[-{Triangle[width=40pt,length=20pt,color=gray]}, line width=20pt, color=gray](-1,-6) -- (11, -6);
%	\end{pgfonlayer}
%\end{tikzpicture}
%
%\caption{TODO WIP, ignore for now}
%
%\label{simple-set-reconciliation-example}
%
%\end{figure*}

\section{Proof of Correctness}
\label{set-reconciliation-simple-correct}

\newcommand{\intcount}[1]{\mathit{count}_{#1}}

We now prove the correctness of the protocol. The protocol is correct if for all $x, y \in U$ both nodes eventually hold $\interval{x}{y}{X_i} \cup \interval{x}{y}{X_j}$ after a node $\mathcal{X}_i$ has received a message pertaining to the interval $[x, y)$.

\begin{caselist}
\case[Interval Item Set] \label{case-iis}  If the message contains the interval item set $\iisnatural{x}{y}{X_j}$, then $\mathcal{X}_i$ adds all items to its set, resulting in $\interval{x}{y}{X_i} \cup \interval{x}{y}{X_j}$ as desired. The other node then receives $\iis{x}{y}{\interval{x}{y}{X_i} \setminus \iisnatural{x}{y}{X_j}}$, ending up with $\interval{x}{y}{X_j} \cup (\iis{x}{y}{\interval{x}{y}{X_i} \setminus \iisnatural{x}{y}{X_j}}) = \interval{x}{y}{X_i} \cup \interval{x}{y}{X_j}$ as desired.

\case[Interval Fingerprint] \label{case-ifp} Otherwise, the message contains an interval fingerprint $\ifp{x}{y}{X_j}$.

\begin{caselist}
\case[Equal Fingerprints] If $\fp{\interval{x}{y}{X_j}} = \fp{\interval{x}{y}{X_i}}$, the protocol terminates immediately and no changes are performed by any node. Assuming no fingerprint collision occurred, $\interval{x}{y}{X_i} = \interval{x}{y}{X_j} = \interval{x}{y}{X_i} \cup \interval{x}{y}{X_j}$ as desired.

\case[Recursion Anchor] \label{case-ifp-anchor} If $\mathcal{X}_i$ adds the interval item set $\iisnatural{x}{y}{X_i}$, then \cref{case-iis} applies when the other node receives the response, with the roles reversed.

\case[Recurse] Let $\intcount{i} \defeq \abs{\interval{x}{y}{X_i}}$ and $\intcount{j} \defeq \abs{\interval{x}{y}{X_j}}$. $\intcount{j} \geq 2$, since otherwise $\mathcal{X}_j$ would have sent an item set for the interval. Similarly, $\intcount{i} \geq 2$, since we are not in \cref{case-ifp-anchor}. Thus, $\intcount{i} + \intcount{j} \geq 4$, and the protocol has already been proven correct for all cases where $\intcount{i} + \intcount{j} < 4$. 

We can thus finish the proof by induction on $\intcount{i} + \intcount{j}$, using the induction hypothesis that for all $x', y' \in U$ such that $\abs{\interval{x'}{y'}{X_i}} + \abs{\interval{x'}{y'}{X_j}} < \intcount{i} + \intcount{j}$ the protocol correctly reconciles $\interval{x'}{y'}{X_i}$ and $\interval{x'}{y'}{X_j}$.

$\mathcal{X}_i$ partitions the interval into $k \geq 2$ subintervals, of which at least two must be nonempty.
Thus $\abs{\interval{m_l}{m_{l + 1}}{X_i}} < \intcount{i}$ for all $0 \leq l < k$.
Furthermore, $\interval{m_l}{m_{l + 1}}{X_j} \subseteq \interval{x}{y}{X_j}$ and thus $\abs{\interval{m_l}{m_{l + 1}}{X_j}} \leq \abs{\interval{x}{y}{X_j}}$, so overall we have $\abs{\interval{m_l}{m_{l + 1}}{X_i}} + \abs{\interval{m_l}{m_{l + 1}}{X_j}} < \intcount{i} + \intcount{j}$ and can apply the induction hypothesis to conclude that every subinterval is correctly reconciled. Since the subintervals partition the original interval, the original interval is then correctly reconciled as well.
\end{caselist}
\end{caselist}

\section{Complexity Analysis}
\label{set-reconciliation-complexity}

The protocol gives nodes the freedom to respond to an interval fingerprint with an interval item set even if the interval fingerprint is arbitrarily large. For a meaningful complexity analysis we need to restrict the behavior of the node, a realistic modus operandi is for a node to send an interval item set whenever it holds a number of items less than or equal to some threshold $t \in \mathbb{N}, t \geq 1$ within the interval. Higher choices for $t$ reduce the number of roundtrips, but increase the probability that a items is being sent even though the other node already holds it.

A node is similarly given freedom over the number of subintervals into which to split an interval when recursing. We will assume a node always splits into at most $b \in \mathbb{N}, b \geq 2$ subintervals. As with $t$, higher numbers reduce the number of roundtrips at the cost of potentially sending items or fingerprints that did not need sending.

Because we want to analyze not only the worst-case complexity but also the complexity depending on the similarity between the two sets held by the participating nodes, we define some rather fine-grained instance size parameters: $n_0$ and $n_1$ denote the number of items held by $\mathcal{X}_0$ and $\mathcal{X}_1$ respectively. We let $n \defeq n_0 + n_1$, $n_{min} \defeq \mathit{min}(n_0, n_1)$, $n_{max} \defeq \mathit{max}(n_0, n_1)$, $n_{\cap} \def \abs{\interval{x}{y}{X_0} \cap \interval{x}{y}{X_1}}$, $n_{\cup} \def \abs{\interval{x}{y}{X_0} \cup \interval{x}{y}{X_1}}$ and $n_{\triangle} \defeq \abs{(\interval{x}{y}{X_0} \cup \interval{x}{y}{X_1}) \setminus (\interval{x}{y}{X_0} \cap \interval{x}{y}{X_1})}$.

\subsection{Preliminary Observations}

The bit-level message complexity depends on the precise encoding of messages. When partitioning an interval into subintervals, it is not necessary to encode both boundaries of every interval since they overlap. When splitting into $b$ subintervals, it suffices to transmit $b + 1$ many boundaries (and of course the corresponding $b$ fingerprints/item sets). If the receiving node remembers which boundaries it has sent in the last round, the two outer boundaries can also be omitted. We will refer to the protocol variant where nodes remember boundaries across communication rounds as the \defined{stateful} protocol variant, and the variant where the outer boundaries of a sequence of subintervals needs to be transmitted as the \defined{stateless} protocol variant.

A helpful observation for the following analysis is that the interval fingerprints that are being exchanged during a protocol run form a rooted tree where every vertex has at most $b$ children. When a leaf of the tree is reached, an exchange of interval item sets follows. Equal fingerprints can also cut the tree short, but for the following worst-case analysis we will assume this does not occur.

Node $\mathcal{X}_i$ can branch at most $\ceil{\mathit{log}_{b}(n_i)}$ times, so the overall height of the tree is bounded by $2 \cdot\ceil{\mathit{log}_{b}(n_{min})}$. The number of vertices of such a tree complete tree of height $h$ is at most $\sum_{i=0}^{h} b^{i} = \frac{b^{h} - 1}{b - 1}$. For $h \leq 2 \cdot\ceil{\mathit{log}_{b}(n_{min})}$, $\frac{b^{h} - 1}{b - 1} \leq 2 \cdot 2 \cdot n_{min} \leq 2n \in \complexity{n}$.

The parameter $t$ determines when recursion is cut off, and thus influences the height of the tree. For $t = 1$, the protocol recurses as far as possible. For $t = b$, the last level of recursion is cut off, for $t = b^2$ the last two levels, and so on. Overall, the height of the tree is reduced by $\floor{\mathit{log}_{b}(t)}$.

\subsection{Communication Rounds}

The number of communication rounds clearly corresponds to the height of the tree, plus $2$ to account for the exchange of interval item sets, so the worst-case is $2 + 2 \cdot\ceil{\mathit{log}_{b}(n_{min})} - \floor{\mathit{log}_{b}(t)} \in \complexity{\mathit{log}_{b}(n)}$. This number cannot be bounded by $n_{\triangle}$, as witnessed by problem instances where one node is missing exactly one item compared to the other node. In such an instance, $b - 1$ branches in each recursion step result in equal fingerprints, but the one branch that does continue reaches the recursion anchor only after the full number of rounds. See \cref{fig:worst-rounds} for an example.

\begin{figure*}
$X_0 \defeq \{\examplea, \exampleb, \examplec, \exampled, \examplee, \exampleg, \exampleh \}$
\hfill
$X_1 \defeq \{\examplea, \exampleb, \examplec, \exampled, \examplee, \examplef, \exampleg, \exampleh \}$

\begin{scaletikzpicturetowidth}{\textwidth}
\begin{tikzpicture}[scale=\tikzscale, font=\tiny]
	\pgfdeclarelayer{background}
	\pgfdeclarelayer{foreground}
	\pgfsetlayers{background,main,foreground}
	
	\begin{pgfonlayer}{main}
		%vertices
		\node (vroot) at (0, 1) [fpi] {\examplefpi{\examplea}{\examplei}{\{\examplea, \exampleb, \examplec, \exampled, \examplee, \examplef, \exampleg, \exampleh\}}};

		\node (v00) at (-4, -0) [fpi] {\examplefpi{\examplea}{\examplee}{\{\examplea, \exampleb, \examplec, \exampled\}}};
		\node (v01) at (4, -0) [fpi] {\examplefpi{\examplee}{\examplei}{\{\examplee, \exampleg, \exampleh\}}};

                \node (v10) at (2, -1) [fpi] {\examplefpi{\examplee}{\exampleg}{\{\examplee, \examplef\}}};
                \node (v11) at (6, -1) [fpi] {\examplefpi{\exampleg}{\examplei}{\{\exampleg, \exampleh\}}};

                \node (v20) at (2, -2) [iis] {\exampleiis{\examplee}{\exampleg}{\{\examplee\}}};

                \node (v30) at (2, -3) [iis] {\exampleiis{\examplee}{\exampleg}{\{\examplef\}}};

		%edges
                \draw (vroot) edge[edge] (v00);
                \draw (vroot) edge[edge] (v01);

		\draw (v01) edge[edge] (v10);
		\draw (v01) edge[edge] (v11);

		\draw (v10) edge[edge] (v20);
		
		\draw (v20) edge[edge] (v30);
	\end{pgfonlayer}
	
	\begin{pgfonlayer}{background}
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](8, 1) -- (-8, 1);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](-8, -0) -- (8, -0);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](8, -1) -- (-8, -1);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](-8, -2) -- (8, -2);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](8, -3) -- (-8, -3);
	\end{pgfonlayer}
\end{tikzpicture}
\end{scaletikzpicturetowidth}

\caption{An example run of the protocol that takes the greatest possible number of rounds even though $n_{\triangle} = 1$. $b \defeq 2, t \defeq 1$.}

\label{fig:worst-rounds}

\end{figure*}

\subsection{Communication Complexity}

The total number of bytes that needs to be transmitted during a protocol run is proportional to the number of vertices in the tree. A group of $b$ vertices whose intervals partition the parent vertex require $(b - 1) \cdot \itemsize$ bytes to encode the interval boundaries in the stateful protocol variant, $(b + 1) \cdot \itemsize$ in the stateless variant. Each interval fingerprint adds another $\fpsize$ bytes for the fingerprint itself. The exchange of interval item sets consists in the worst case of exchanging every item using $\ceil{\frac{n}{t}}$ interval item sets, adding another $4 \cdot \itemsize + t \cdot \itemsize$ bytes in the stateless version (the first summand accounts for the two boundary items being sent by each node), or simply $t \cdot \itemsize$ bytes in the stateful version.

Overall, the complexity is TODO

\Cref{fig:worst-bytes} shows a worst-case example, in which the tree of height $h \defeq \mathit{log}_{b}(2 \cdot n_{min})$ has all $\frac{b^{h} - 1}{b - 1}$ vertices. 

\begin{figure*}
$X_0 \defeq \{\examplea, \examplec, \examplee, \exampleg \}$
\hfill
$X_1 \defeq \{\examplea, \exampleb, \examplec, \exampled, \examplee, \examplef, \exampleg, \exampleh\}$

\begin{scaletikzpicturetowidth}{\textwidth}
\begin{tikzpicture}[scale=\tikzscale, font=\tiny]
	\pgfdeclarelayer{background}
	\pgfdeclarelayer{foreground}
	\pgfsetlayers{background,main,foreground}
	
	\begin{pgfonlayer}{main}
		%vertices
		\node (vroot) at (0, 1) [fpi] {\examplefpi{\examplea}{\examplei}{\{\examplea, \exampleb, \examplec, \exampled, \examplee, \examplef, \exampleg, \exampleh\}}};

		\node (v00) at (-4, -0) [fpi] {\examplefpi{\examplea}{\examplee}{\{\examplea, \examplec\}}};
		\node (v01) at (4, -0) [fpi] {\examplefpi{\examplee}{\examplei}{\{\examplee, \exampleg\}}};

                \node (v10) at (-6, -1) [fpi] {\examplefpi{\examplea}{\examplec}{\{\examplea, \exampleb\}}};
                \node (v11) at (-2, -1) [fpi] {\examplefpi{\examplec}{\examplee}{\{\examplec, \exampled\}}};
                \node (v12) at (2, -1) [fpi] {\examplefpi{\examplee}{\exampleg}{\{\examplee, \examplef\}}};
                \node (v13) at (6, -1) [fpi] {\examplefpi{\exampleg}{\examplei}{\{\exampleg, \exampleh\}}};

                \node (v20) at (-6, -2) [iis] {\exampleiis{\examplea}{\examplec}{\{\examplea\}}};
                \node (v21) at (-2, -2) [iis] {\exampleiis{\examplec}{\examplee}{\{\examplec\}}};
                \node (v22) at (2, -2) [iis] {\exampleiis{\examplee}{\exampleg}{\{\examplee\}}};
                \node (v23) at (6, -2) [iis] {\exampleiis{\exampleg}{\examplei}{\{\exampleg\}}};

                \node (v30) at (-6, -3) [iis] {\exampleiis{\examplea}{\examplec}{\{\exampleb\}}};
                \node (v31) at (-2, -3) [iis] {\exampleiis{\examplec}{\examplee}{\{\exampled\}}};
                \node (v32) at (2, -3) [iis] {\exampleiis{\examplee}{\exampleg}{\{\examplef\}}};
                \node (v33) at (6, -3) [iis] {\exampleiis{\exampleg}{\examplei}{\{\exampleh\}}};
		%edges
                \draw (vroot) edge[edge] (v00);
                \draw (vroot) edge[edge] (v01);

		\draw (v00) edge[edge] (v10);
		\draw (v00) edge[edge] (v11);
		\draw (v01) edge[edge] (v12);
		\draw (v01) edge[edge] (v13);

		\draw (v10) edge[edge] (v20);
		\draw (v11) edge[edge] (v21);
		\draw (v12) edge[edge] (v22);
		\draw (v13) edge[edge] (v23);

		\draw (v20) edge[edge] (v30);
		\draw (v21) edge[edge] (v31);
		\draw (v22) edge[edge] (v32);
		\draw (v23) edge[edge] (v33);
	\end{pgfonlayer}
	
	\begin{pgfonlayer}{background}
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](8, 1) -- (-8, 1);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](-8, -0) -- (8, -0);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](8, -1) -- (-8, -1);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](-8, -2) -- (8, -2);
		\draw[-{Triangle[width=30pt,length=17pt,color=gray]}, line width=15pt, color=gray](8, -3) -- (-8, -3);
	\end{pgfonlayer}
\end{tikzpicture}
\end{scaletikzpicturetowidth}

\caption{An example run of the protocol that requires transmitting the maximum amount of bytes. $b \defeq 2, t \defeq 1$.}

\label{fig:worst-bytes}
\end{figure*}

\subsection{Computational Complexity}

TODO (write fingerprint chapter first?)

\section{Generic Optimizations}
\label{set-reconciliation-simple-optimizations}

While the simple formulation of the protocol is nicely suitable for a correctness proof, there are some cases that can be handled much more efficiently. We briefly discuss them and then present an optimized version of the protocol.

\subsection{Detecting Singletons}

When receiving an interval fingerprint $\ifp{x}{y}{X_i}$, a node can check whether $\fp{\{x\}} =  \fp{\interval{x}{y}{X_i}}$. If this is the case, $\mathcal{X}_i$ only stores $x$ within the interval, so $\mathcal{X}_j$ can act as if it received the item $x$ and the interval fingerprint $\ifpmanual{l}{y}{\neutraladd}$ where $l$ is the least element in $X_j$ such that $x \prec l \preceq y$.

\subsection{Encodings}

A first, simple encoding optimization is to encode empty intervals not via $\neutraladd$, but as a dedicated message part. This allows a more compact representation, which is appropriate since $\neutraladd$ should by far be the most frequently occurring fingerprint. We will designate an \defined{empty interval fingerprint} as $\ifpempty{x}{y}$.

A second optimization that merely changes the encoding of messages consists of a more compact representation of ``adjacent'' intervals: Interval boundaries $[x_0, x_1), [x_1, x_2), \ldots, [x_{k - 1}, x_k)$ can be encoded as a simple list $x_0, x_1, \ldots, x_{k - 1}, x_k$. As long as the protocol only talks about intervals which partition the original interval, expressing $k$ interval boundaries only consumes $1 + k$ space as opposed to the naÃ¯ve $2k$.

We can in fact do even better: when a node receives some interval $[x, y)$ and splits it into $[x, m)$ and $[m, y)$, it merely needs to send $m$ to the other node. If the other node can reconstruct which interval is being split at point $m$, then all the necessary information has been conveyed. Since any $m$ falls into exactly one previously used interval, there can be no ambiguity. It thus suffices to send triples $( \mathit{fingerprint}_{\prec m}, m, \mathit{fingerprint}_{\succeq m})$. As a consequence, any particular $u \in U$ is transmitted at most one time during a protocol run. This optimization does however come at the cost of nodes needing to store interval boundaries across communication rounds.

\subsection{Branching Degree}

For the correctness of the protocol, large, populated intervals need to be partitioned and then recursively reconciled. It does however neither matter to partition the intervals into exactly two subintervals, nor that the intervals are evenly partitioned in the middle. Increasing the number of subintervals per recursion step reduces the total number of roundtrips at the cost of less efficient bandwidth usage, as will be seen in the complexity analysis in \cref{set-reconciliation-complexity}.

In a similar vein, there is no inherent reason to initiate reconciliation by only sending a single fingerprint for the whole interval of interest, the initiating node and just as well partition the interval of interest and send fingerprints for each subinterval.

Splitting intervals into partitions of unequal sizes can be beneficial if missing items are not expected to be distributed uniformly at random across the whole order. Items might for example be ordered by the time at which they were created, a long-running node would then expect a continuous stream of new items, but would rarely receive an unknown item from the far past. Interval selection could reflect this by e.g. partitioning the $\frac{1}{2}$ oldest items into the first subinterval, then the next $\frac{1}{4}$ into the second subinterval, the next $\frac{1}{8}$ into the third, and so on. If unknown old items are rare enough, the average size of intervals which require recursion is less than under a split into intervals of equal sizes.

%\subsection{Utilizing Interval Boundaries}
%\label{utilizing-boundaries}
%
%The next two optimizations stem from the fact that roughly half of all intervals include their lower boundary. When a node receives an interval fingerprint starting at some $x \in U$ and knows that the other node holds that $x$, it can simply add $x$ to its own set and $x$ can be excluded from any further reconciliation effort.
%
%An optimization that can be applied independent of $U$ and $\preceq$ is to introduce \defined{lower singleton intervals}, ranging from $x$ to $y$ and containing no item but $x$, denoted as $\ifpsingle{x}{y}$. When $\mathcal{X}_i$ receives a lower singleton interval $\ifpsingle{x}{y}$, it can reply with all items $u$ such that $x \prec u \prec y$. If $x \notin X_i$, it adds it to the set, otherwise no further action is necessary. This optimization shaves off one communication round in \cref{two-singletons} because $\mathcal{X}_1$ responds with $\ifpsingle{u1}{y}$ rather than $\ifpmanual{u_1}{y}{\fp{u_1}}$, thus finishing reconciliation in at most one more communication round.
%
%In order to efficiently leverage the knowledge that some interval of size at least two contains its lower boundary, $\preceq$ must be antidense:
%
%\begin{definition}
%Let $U$ be a set and $\preceq$ be a linear order on $u$. We call $\preceq$ \defined{antidense} if for all $x \in U$, if there exists $y \in U$ such that $x \prec y$, then there exists a least such element, denoted as $\successor{x}$.
%\end{definition}
%
%If $\preceq$ is antidense, we can introduce \defined{least-containing intervals}, ranging from $x$ to $y$ and guaranteed to contain $x$ and some other items whose fingerprint is $f$, denoted $\ifpcontain{x}{y}{f}$ (this is just a notation, $\fp{x}$ does not have to be transmitted). A node receiving a least-containing interval $\ifpcontain{x}{y}{f}$ reacts as if it received the item $x$ and the regular interval fingerprint $\ifpmanual{\successor{x}}{y}{f}$. Furthermore, whenever $\mathcal{X}_i$ sends a regular interval fingerprint $\ifp{x}{y}{X_i}$ and then receives a regular interval fingerprint $\ifp{x}{m}{X_j}$, neither node has item $x$, so $\mathcal{X}_i$ can act as if it received $\ifp{\successor{x}}{y}{X_j}$ instead.
%In both of these cases, if $\successor{x}$ is not defined, i.e. $x$ is the maximal element of the order, the notes merely act as if they just reconciled $x$ and do not perform any further work.
%
%This approach explicitly adds a single bit of information to each interval, namely whether the lower boundary is contained or not. A different approach is to implicitly distinguish between intervals that definitely contain the lower boundary, i.e. the greater of the two intervals obtained after a split, and intervals that may or may not contain their lower boundary, i.e. all other intervals. In this setting, sending and receiving a regular interval with the same lower boundary does not imply that the other node does not hold that item.
%
%Utilizing this information can even be done for universes with a non-antidense order, by introducing intervals which exclude both their boundaries: $\intervalx{x}{y}{A} \defeq \{a \in A | x \prec a \prec y\}$. When a node receives an interval $\interval{m}{y}{X_i}$ which is a greater interval obtained from a split, it reacts as if it received the item $x$ and the fingerprint over the interval $\ifpmanual{m}{y}{\intervalx{m}{y}{X_i}}$.
%
%\subsection{Bounded Boundaries}
%
%The boundaries of intervals come from the universe $U$ and need to be transmitted. If $U$ contains arbitrarily large elements, e.g. $U \defeq \{0, 1\}^{\ast}$, the protocol cannot uphold any reasonable complexity guarantees. The solution is to employ indirection, for example by hashing the items from $U$ and then comparing the hashes lexicographically rather than using any order on $U$. After the protocol has terminated, each node holds the hashes of the items it is missing.
%
%As a last phase, the nodes can then exchange those lists of hashes and answer with the items thus requested by the other node. Alternatively, the items could be retrieved from some content-addressable storage substrate. Both of these solutions add additional roundtrips to the reconciliation. A more efficient solution is to make the protocol aware of the difference between the hashes being used for interval delimiting and the actual items of interest. Whenever the protocol determines that an item needs to be transmitted, the node transmits the actual item rather than the hash.
%
%If the protocol is made aware of the difference and inlines items, most of the optimizations from \cref{utilizing-boundaries} become inapplicable, since knowing that the other node holds an item hashing to some lower boundary of an interval is not the same as obtaining that item. The only optimization in the same spirit that can be applied as the following: if a node $\mathcal{X}_i$ receives an interval fingerprint $\ifpmanual{m}{y}{\fp{m}}$, it can act as if it received an interval containing only $m$ and it additionally sends all items in $\intervalx{m}{y}{X_i}$.
%
%The interval boundaries do not necessarily have to be only the hashes of the items, additional information can be added so that the order on the boundaries exhibit similarity with some order on the items. Hashing has to be involved though in order to map the infinite universe to a finite set of boundaries with a low probability of collisions.

\section{Reconciling Hash Graphs}
\label{set-reconciliation-simple-graphs}
